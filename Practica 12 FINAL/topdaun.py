# -*- coding: utf-8 -*-
"""TOPDAUN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pq0lmtGYVdqEzbnjOGp0SqfYRrK6iabR
"""

import time
from functools import lru_cache

def fibonacci_top_down(n, memori=None):
    if not isinstance(n, int):
        raise TypeError("n debe ser un entero >= 0")
    if n < 0:
        raise ValueError("n debe ser >= 0")

    if memori is None:
        memori = {0: 0, 1: 1}

    if n in memori:
        return memori[n]

    res = fibonacci_top_down(n-1, memori) + fibonacci_top_down(n-2, memori)
    memori[n] = res
    return res

# Alternativa r√°pida con lru_cache
@lru_cache(maxsize=None)
def Fibonachi_fast(n):
    if n < 0:
        raise ValueError("n debe ser >= 0")
    if n == 0:
        return 0
    if n == 1:
        return 1
    return Fibonachi_fast(n-1) + Fibonachi_fast(n-2)

def main():
    pruebas = [0, 1, 2, 5, 10, 20, 30]
    print("Top-down Fibonacci (diccionario)")
    for act in pruebas:
        p0 = time.perf_counter()
        val = fibonacci_top_down(act)
        p1 = time.perf_counter()
        print(f"F({act}) = {val}  (tiempo: {(p1-p0)*1000:.4f} ms)")

    print("\nTop-down Fibonacci (lru_cache) - comparativa")
    for act in pruebas:
        p0 = time.perf_counter()
        val = Fibonachi_fast(act)
        p1 = time.perf_counter()
        print(f"F({act}) = {val}  (tiempo: {(p1-p0)*1000:.4f} ms)")

if __name__ == "__main__":
    main()